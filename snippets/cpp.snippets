snippet cp "CP Template" b
// Then which of Allah's favor will you deny?
// author: MushfiqTalha
#include <bits/stdc++.h>
#define all(v) begin(v), end(v)
#ifdef LOCAL
#include <dbg.h>
#else
#define dbg(...)
#endif
using namespace std;
typedef long long LL;
typedef pair<int, int> PII;

int main() {
	cin.tie(NULL)->sync_with_stdio(false);

	${0}

	return 0;
}
endsnippet

snippet tests "Tests in C++" b
int t; cin >> t;
for (int tc = 1; tc <= t; tc++) {
	${0}
}
endsnippet

snippet rng "Mersienne Twister Random Generator" b
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
endsnippet

snippet lazy "Lazy Segment Tree"
namespace segtree {
  const int N = ${1:1000006};

  using DT = $2;
  using LT = $3;
  const DT I = $4;
  const LT None = $5;

  DT val[N<<2];
  LT lz[N<<2];
  int L, R;
  void apply(int u, const LT &U, int l, int r) {
    if (U == None) return;
		$6
  }
  DT merge(const DT &a, const DT &b, int l, int r) {
		$7
  }
  /* -- Do Not Touch Anything Below This -- */

  void push(int l, int r, int u) {
    if(l == r) return;
    apply(u << 1, lz[u], l, l+r >> 1);
    apply(u << 1 | 1, lz[u], l+r+2 >> 1, r);
    lz[u] = None;
  }
  void build(int l, int r, vector <DT> const &v, int u = 1 ) {
    lz[u] = None;
    if(l == r) {
      val[u] = v[l];
      return;
    }
    int m = l+r >> 1, lft = u << 1, ryt = lft | 1;
    build(l, m, v, lft);
    build(m+1, r, v, ryt);
    val[u] = merge(val[lft], val[ryt], l, r);
  }
  void update(int ql,int qr, LT uval, int l = L, int r = R, int u = 1) {
    if (qr < l or ql > r) return;
    if(ql <= l and r <= qr) {
      apply(u, uval, l, r);
      return;
    }
    push(l, r, u);
    int m = l+r >> 1, lft = u << 1, ryt = lft | 1;
    update(ql, qr, uval,  l,  m, lft);
    update(ql, qr, uval, m+1, r, ryt);
    val[u] = merge(val[lft], val[ryt], l, r);
  }
  DT query(int ql, int qr, int l = L, int r = R, int u = 1) {
    if (qr < l or ql > r) return I;
    if (ql <= l and r <= qr) return val[u];
    push(l, r, u);
    int m = l+r >> 1, lft = u << 1, ryt = lft | 1;
    DT ansl = query(ql, qr, l, m, lft);
    DT ansr = query(ql, qr, m + 1, r, ryt);
    return merge(ansl, ansr, l, r);
  }
  void init(int _L, int _R, vector <DT> v) {
    L = _L, R = _R;
    build(L, R, v);
  }
};
endsnippet
